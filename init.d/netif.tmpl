#!/sbin/runscript
# Copyright (c) 2007-2009 Funtoo Technologies
# All rights reserved. Released under the 2-clause BSD license.

# TODO - generate cached templates for /etc/init.d/foo, use them for starting and stopping
# rather than running "live" commands. This way "stop" will work correctly.

# I may want to change INT to have the format netif.eth0-<vlan,etc.> to
# make the network info differentiated from the stacked runlevel name.
# otherwise, /etc/conf.d might be odd and it will be confusing to differentiate
# between the following:
# 
# netif.eth0.home (home runlevel)
# netif.eth0.32 (VLAN 32 or runlevel 32?)
# 
# 
# vs:
# 
# netif.eth0.home (home runlevel)
# netif.eth0-32.home (vlan 32, home runlevel)

INT=${RC_SVCNAME#netif.}
interface=${interface:-$INT}

[ "$interface" = "tmpl" ] && exit 0

settings="/etc/conf.d/netif.${interface}"

if [ ! -e "$settings" ]
then
	error "Settings $settings not found."
	exit 1
fi

. $settings

if [ -z "$template" ]
then
	eerror "Please specify a template (template=) for $RC_SVCNAME in $settings"
	exit 1
fi

BLUE="[34;01m"
CYAN="[36;01m"
CYANN="[36m"
GREEN="[32;01m"
RED="[31;01m"
PURP="[35;01m"
YEL="[33;01m"
BOLD="[01m"
OFF="[0m"

if [ -n "$description" ]
then
	DESC1="$interface${OFF}"
	DESC2="${CYAN}${description}${OFF}"
else
	DESC1="$interface${OFF}"
	DESC2="${CYANN}${template}${OFF}"
fi
STARTD="Interface $DESC1 ${GREEN}up${OFF} - $DESC2"
STOPD="Interface $DESC1 ${RED}down${OFF} - $DESC2"

src_template="/etc/netif.d/$template"

require() {
	local missing=""
	for envname in $*
	do
		[ -z "${!envname}" ] && missing="$missing $envname"
	done
	if [ -n "$missing" ]
	then
		echo
		eerror "ERROR: Required variable(s) are missing from ${CYAN}$settings${OFF}:"
		eerror ""
		for miss in $missing
		do
			eerror "    ${CYAN}$miss${OFF}"
		done
		eerror ""
		eerror "Please correct ${CYAN}$settings${OFF} to address this issue."
		echo
		exit 1
	fi
}

die() {
	eend 1 "$*"; exit 1
}

depend() {
	config "$settings"
	need root
	# call netif_depend function... if it exists
	declare -f netif_depend > /dev/null
	[ -n "${trunk}" ] && need "netif.${trunk}"
	[ -n "$slaves" ] && need $slaves
	[ $? -eq 0 ] && netif_depend
}

netif_pre_up() {
}

netif_post_up() {
}

netif_pre_down() {
}

netif_post_down() {
}

start() {
	ebegin "$STARTD"
	ip addr flush dev $interface
	if [ -n "$trunk" ]; then
		ip link add dev ${interface} link ${trunk} type vlan id ${vlan} || die "Couldn't configure VLAN ${vlan} on ${trunk}"
	fi
	netif_pre_up
	ip link set $interface up
	if [ -n "$mtu" ]
	then
		ip link set $interface mtu $mtu
		if [ -n "$slaves" ]; then
			for slave in ${slaves//netif./}; do
				ip link set $slave mtu $mtu || eend $?
			done
		fi
	fi
	ezroute add; ezresolv add
	netif_start
	eend $?
}

stop() {
	ebegin "$STOPD"
	netif_pre_down
	ezresolv del; ezroute del
	ip link set $interface down
	ip addr flush dev $interface
	netif_post_down
	# VLANS:
	[ -n "${trunk}" ] && ip link delete ${interface}
	eend 0
}

domain=${domain:-$DOM}
if [ -n "$IP" ]
then
	ipaddr=$IP/$NM
fi
netmask=${netmask:-$NM}
slaves=${slaves:-$SLAVES}
mtu=${mtu:-$MTU}
nameservers="${nameservers:-$NS1 $NS2}"
gateway=${gateway:-$GW}

start_pre() {
	if [ -n "$ipaddr $ipaddrs" ]
	then
		for i in $ipaddr $ipaddrs
		do
			if [ "${i##*/}" = "$i" ]
			then
				echo
				ewarn "You probably want to add a netmask to the ipaddr $i defined in $settings."
				ewarn "Example: ipaddr=\"192.168.0.1/24\""
				echo
			fi
		done
	fi
}

ezdns() {
	# This function generates a resolv.conf entry, which ezresolv() passes to resolvconf
	[ -n "$domain" ] && echo "domain $domain"
	for ns in $nameservers
	do
		echo "nameserver $ns"
	done
}

ezresolv() {
	# This function calls resolvconf (openresolv) with the correct resolv.conf passed as a here-file
	if [ "$1" = "add" ]; then
		[ -z "`ezdns`" ] && return
		resolvconf -a $interface << EOF || die "Problem adding DNS info for $interface"
`ezdns`
EOF
	else
		resolvconf -d $interface
	fi
}

ezroute() {
	if [ "$gateway" = "default" ]
	then
		qipr $1 default dev $interface
	elif [ -n "$gateway" ]
	then
		qipr $1 default via $gateway
	fi
}

qipr() {
	ip route $*
	[ "$1" = "add" ] && [ $? -ne 0 ] && die "Couldn't set route: $*"
}


if [ -z "$trunk" ]; then
	# auto-detect trunk/vlan ID from interface name -
	# interface "eth0.32" would have trunk of "eth0" and vlan of "32":
	autovlan=1
	vlan="${interface##*.}"
	trunk="${interface%.*}"
	# vlan and trunk will be "" for a regular interface (i.e. "eth0")
else
	# user has specified a trunk of something like "eth0" (maybe this
	# interface is called "mgmt") .In this case, we expect vlan to be 
	# defined in the config file too.
	autovlan=0
	require vlan
fi

. $src_template

